# mmap

## What is Mmap

本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作  

mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了.  
写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用msync()来显式同步一下, 这样你所写的内容就能立即保存到文件里了.  这点应该和驱动相关. 不过通过mmap来写文件这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.  如果想取消内存映射，可以调用munmap()来取消内存映射  


<img src="https://user-images.githubusercontent.com/16873751/96791296-093a0780-13ad-11eb-99bc-b7f827657510.png" alt="why memap is fast" width="600"/>


映射，主要是指 硬盘上的文件的位置与进程的逻辑地址空间中一块大小相同的区域进行的对应

过程1，mmap调用之后返回个ptr， 并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存  

过程2，对于文件的读写都可以操作ptr，但是ptr是指向一个逻辑地址，要操作其中的数据必须把逻辑地址转为虚拟地址，也就是靠MMU  

过程3，MMU在地址映射表中没有找到ptr对应的物理地址，MMU失败将会产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中  

过程4，在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上  


## 为什么内存映射的效率高

对于普通的读写，read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，如下面的过程1，然后再将这些数据拷贝到用户空间，如过程2，在这个过程中，实际上完成了 两次数据拷贝 ；而mmap()也是系统调用，如前所述，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 一次数据拷贝 。因此，内存映射的效率要比read/write效率高

<img src="https://user-images.githubusercontent.com/16873751/96791302-0d662500-13ad-11eb-9a87-84e3e1559613.png" alt="why memap is fast" width="600"/>


